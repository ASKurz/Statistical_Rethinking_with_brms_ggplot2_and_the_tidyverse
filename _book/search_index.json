[
["monsters-and-mixtures.html", "11 Monsters and Mixtures 11.1 Ordered categorical outcomes 11.2 Zero-inflated outcomes 11.3 Over-dispersed outcomes Reference Session info", " 11 Monsters and Mixtures [Of these majestic creatures], we’ll consider two common and useful examples. The first type is the ordered categorical model, useful for categorical outcomes with a fixed ordering. This model is built by merging a categorical likelihood function with a special kind of link function, usually a cumulative link. The second type is a family of zero-inflated and zero-augmented models, each of which mixes a binary event within an ordinary GLM likelihood like a Poisson or binomial. Both types of models help us transform our modeling to cope with the inconvenient realities of measurement, rather than transforming measurements to cope with the constraints of our models. (p. 331) 11.1 Ordered categorical outcomes It is very common in the social sciences, and occasional in the natural sciences, to have an outcome variable that is discrete, like a count, but in which the values merely indicate different ordered levels along some dimension. For example, if I were to ask you how much you like to eat fish, on a scale from 1 to 7, you might say 5. If I were to ask 100 people the same question, I’d end up with 100 values between 1 and 7. In modeling each outcome value, I’d have to keep in mind that these values are ordered because 7 is greater than 6, which is greater than 5, and so on. But unlike a count, the differences in values are not necessarily equal. In principle, an ordered categorical variable is just a multinomial prediction problem (page 323). But the constraint that the categories be ordered demands special treatment… The conventional solution is to use a cumulative link function. The cumulative probability of a value is the probability of that value or any smaller value. (pp. 331–332, emphasis in the original) 11.1.1 Example: Moral intuition. Let’s get the Trolley data from rethinking. library(rethinking) data(Trolley) d &lt;- Trolley Unload rethinking and load brms. rm(Trolley) detach(package:rethinking, unload = T) library(brms) Use the tidyverse to get a sense of the dimensions of the data. library(tidyverse) glimpse(d) ## Observations: 9,930 ## Variables: 12 ## $ case &lt;fct&gt; cfaqu, cfbur, cfrub, cibox, cibur, cispe, fkaqu, fkboa… ## $ response &lt;int&gt; 4, 3, 4, 3, 3, 3, 5, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, … ## $ order &lt;int&gt; 2, 31, 16, 32, 4, 9, 29, 12, 23, 22, 27, 19, 14, 3, 18… ## $ id &lt;fct&gt; 96;434, 96;434, 96;434, 96;434, 96;434, 96;434, 96;434… ## $ age &lt;int&gt; 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14… ## $ male &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ edu &lt;fct&gt; Middle School, Middle School, Middle School, Middle Sc… ## $ action &lt;int&gt; 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, … ## $ intention &lt;int&gt; 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ contact &lt;int&gt; 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ story &lt;fct&gt; aqu, bur, rub, box, bur, spe, aqu, boa, box, bur, car,… ## $ action2 &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, … Though we have 9,930 rows, we only have 331 unique individuals. d %&gt;% distinct(id) %&gt;% count() ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 331 11.1.2 Describing an ordered distribution with intercepts. Before we get to plotting, in this chapter we’ll use theme settings and a color palette from the ggthemes package, which you might learn more about here. library(ggthemes) We’ll take our basic theme settings from the theme_hc() function. We’ll use the “Green fields” color palette, which we can inspect with the canva_pal() function and a little help from scales::show_col(). scales::show_col(canva_pal(&quot;Green fields&quot;)(4)) canva_pal(&quot;Green fields&quot;)(4) ## [1] &quot;#919636&quot; &quot;#524a3a&quot; &quot;#fffae1&quot; &quot;#5a5f37&quot; canva_pal(&quot;Green fields&quot;)(4)[3] ## [1] &quot;#fffae1&quot; Now we’re ready to make our ggplot2 version of the simple histogram, Figure 11.1.a. ggplot(data = d, aes(x = response, fill = ..x..)) + geom_histogram(binwidth = 1/4, size = 0) + scale_x_continuous(breaks = 1:7) + scale_fill_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + theme_hc() + theme(axis.ticks.x = element_blank(), plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) Our cumulative proportion plot, Figure 11.1.b, will require some pre-plot wrangling. d %&gt;% group_by(response) %&gt;% count() %&gt;% mutate(pr_k = n / nrow(d)) %&gt;% ungroup() %&gt;% mutate(cum_pr_k = cumsum(pr_k)) %&gt;% ggplot(aes(x = response, y = cum_pr_k, fill = response)) + geom_line(color = canva_pal(&quot;Green fields&quot;)(4)[2]) + geom_point(shape = 21, colour = &quot;grey92&quot;, size = 2.5, stroke = 1) + scale_x_continuous(breaks = 1:7) + scale_y_continuous(&quot;cumulative proportion&quot;, breaks = c(0, .5, 1)) + scale_fill_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + coord_cartesian(ylim = c(0, 1)) + theme_hc() + theme(axis.ticks.x = element_blank(), plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) In order to make the next plot, we’ll need McElreath’s logit() function. Here it is, the logarithm of cumulative odds plot, Figure 11.1.c. # McElreath&#39;s convenience function from page 335 logit &lt;- function(x) log(x / (1 - x)) d %&gt;% group_by(response) %&gt;% count() %&gt;% mutate(pr_k = n / nrow(d)) %&gt;% ungroup() %&gt;% mutate(cum_pr_k = cumsum(pr_k)) %&gt;% filter(response &lt; 7) %&gt;% # we can do the `logit()` conversion right in ggplot2 ggplot(aes(x = response, y = logit(cum_pr_k), fill = response)) + geom_line(color = canva_pal(&quot;Green fields&quot;)(4)[2]) + geom_point(shape = 21, colour = &quot;grey92&quot;, size = 2.5, stroke = 1) + scale_x_continuous(breaks = 1:7) + scale_fill_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + coord_cartesian(xlim = c(1, 7)) + ylab(&quot;log-cumulative-odds&quot;) + theme_hc() + theme(axis.ticks.x = element_blank(), plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) The code for Figure 11.2 is itself something of a monster. d_plot &lt;- d %&gt;% group_by(response) %&gt;% count() %&gt;% mutate(pr_k = n / nrow(d)) %&gt;% ungroup() %&gt;% mutate(cum_pr_k = cumsum(pr_k)) ggplot(data = d_plot, aes(x = response, y = cum_pr_k, color = cum_pr_k, fill = cum_pr_k)) + geom_line(color = canva_pal(&quot;Green fields&quot;)(4)[1]) + geom_point(shape = 21, colour = &quot;grey92&quot;, size = 2.5, stroke = 1) + geom_linerange(aes(ymin = 0, ymax = cum_pr_k), alpha = 1/2, color = canva_pal(&quot;Green fields&quot;)(4)[1]) + # there must be more elegant ways to do this part geom_linerange(data = . %&gt;% mutate(discrete_probability = ifelse(response == 1, cum_pr_k, cum_pr_k - pr_k)), aes(x = response + .025, ymin = ifelse(response == 1, 0, discrete_probability), ymax = cum_pr_k), color = &quot;black&quot;) + geom_text(data = tibble(text = 1:7, response = seq(from = 1.25, to = 7.25, by = 1), cum_pr_k = d_plot$cum_pr_k - .065), aes(label = text), size = 4) + scale_x_continuous(breaks = 1:7) + scale_y_continuous(&quot;cumulative proportion&quot;, breaks = c(0, .5, 1)) + scale_fill_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + scale_color_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + coord_cartesian(ylim = c(0, 1)) + theme_hc() + theme(axis.ticks.x = element_blank(), plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) McElreath’s convention for this first type of statistical model is \\[ \\begin{eqnarray} R_i &amp; \\sim &amp; \\text{Ordered} (\\mathbf p) \\\\ \\text{logit} (p_k) &amp; = &amp; \\alpha_k \\\\ \\alpha_k &amp; \\sim &amp; \\text{Normal} (0, 10) \\end{eqnarray} \\] The Ordered distribution is really just a categorical distribution that takes a vector \\(\\mathbf p = {p_1, p_2, p_3, p_4, p_5, p_6}\\) of probabilities of each response value below the maximum response (7 in this example). Each response value \\(k\\) in this vector is defined by its link to an intercept parameter, \\(\\alpha_k\\). Finally, some weakly regularizing priors are placed on these intercepts. (p. 335) Whereas in rethinking::map() you indicate the likelihood by &lt;criterion&gt; ~ dordlogit(phi , c(&lt;the thresholds&gt;), in brms::brm() you code family = cumulative. Here’s the intercepts-only model: # define the start values inits &lt;- list(`Intercept[1]` = -2, `Intercept[2]` = -1, `Intercept[3]` = 0, `Intercept[4]` = 1, `Intercept[5]` = 2, `Intercept[6]` = 2.5) inits_list &lt;- list(inits, inits) b11.1 &lt;- brm(data = d, family = cumulative, response ~ 1, prior(normal(0, 10), class = Intercept), iter = 2000, warmup = 1000, cores = 2, chains = 2, inits = inits_list, # here we add our start values seed = 11) McElreath needed to include the depth=2 argument in the rethinking::precis() function to show the threshold parameters from his m11.1stan model. With a brm() fit, we just use print() or summary() as usual. print(b11.1) ## Family: cumulative ## Links: mu = logit; disc = identity ## Formula: response ~ 1 ## Data: d (Number of observations: 9930) ## Samples: 2 chains, each with iter = 2000; warmup = 1000; thin = 1; ## total post-warmup samples = 2000 ## ## Population-Level Effects: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## Intercept[1] -1.92 0.03 -1.97 -1.86 1476 1.00 ## Intercept[2] -1.27 0.02 -1.31 -1.22 1821 1.00 ## Intercept[3] -0.72 0.02 -0.76 -0.68 2021 1.00 ## Intercept[4] 0.25 0.02 0.21 0.29 2216 1.00 ## Intercept[5] 0.89 0.02 0.85 0.93 2327 1.00 ## Intercept[6] 1.77 0.03 1.72 1.83 2482 1.00 ## ## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample ## is a crude measure of effective sample size, and Rhat is the potential ## scale reduction factor on split chains (at convergence, Rhat = 1). What McElreath’s m11.1stan summary termed cutpoints[k], ours termed Intercept[k]. In both cases, these are the \\(\\alpha_k\\) parameters from the equations, above. The summaries look like those in the text, number of effective samples are high, and the \\(\\hat{R}\\) values are great. The model looks good. Recall we use the brms::inv_logit_scaled() function in place of McElreath’s logistic() function to get these into the probability metric. b11.1 %&gt;% fixef() %&gt;% inv_logit_scaled() ## Estimate Est.Error Q2.5 Q97.5 ## Intercept[1] 0.1282430 0.5072421 0.1222287 0.1346667 ## Intercept[2] 0.2197474 0.5058551 0.2120979 0.2277862 ## Intercept[3] 0.3277541 0.5053708 0.3181448 0.3369461 ## Intercept[4] 0.5616313 0.5051667 0.5515424 0.5715200 ## Intercept[5] 0.7090137 0.5054678 0.7006442 0.7176885 ## Intercept[6] 0.8545209 0.5071545 0.8475148 0.8613844 But recall that the posterior \\(SD\\) (i.e., the ‘Est.Error’ values) are not valid using that approach. If you really care about them, you’ll need to work with the posterior_samples(). posterior_samples(b11.1) %&gt;% select(starts_with(&quot;b_&quot;)) %&gt;% mutate_all(inv_logit_scaled) %&gt;% gather() %&gt;% group_by(key) %&gt;% summarise(mean = mean(value), sd = sd(value), ll = quantile(value, probs = .025), ul = quantile(value, probs = .975)) ## # A tibble: 6 x 5 ## key mean sd ll ul ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 b_Intercept[1] 0.128 0.00324 0.122 0.135 ## 2 b_Intercept[2] 0.220 0.00402 0.212 0.228 ## 3 b_Intercept[3] 0.328 0.00473 0.318 0.337 ## 4 b_Intercept[4] 0.562 0.00509 0.552 0.572 ## 5 b_Intercept[5] 0.709 0.00451 0.701 0.718 ## 6 b_Intercept[6] 0.854 0.00356 0.848 0.861 11.1.3 Adding predictor variables. Now we define the linear model as \\(\\phi_i = \\beta x_i\\). Accordingly, the formula for our cumulative logit model becomes \\[ \\begin{eqnarray} \\text{log} \\frac{\\text{Pr} (y_i \\leq k)}{1 - \\text{Pr} (y_i \\leq k)} &amp; = &amp; \\alpha_k - \\phi_i\\\\ \\phi_i &amp; = &amp; \\beta x_i \\end{eqnarray} \\] I’m not aware that brms has an equivalent to the rethinking::dordlogit() function. So here we’ll make it by hand. The code comes from McElreath’s GitHub page. # first, we needed to specify the `logistic()` function, which is apart of the `dordlogit()` function logistic &lt;- function(x) { p &lt;- 1 / (1 + exp(-x)) p &lt;- ifelse(x == Inf, 1, p) p } # now we get down to it dordlogit &lt;- function(x, phi, a, log = FALSE) { a &lt;- c(as.numeric(a), Inf) p &lt;- logistic(a[x] - phi) na &lt;- c(-Inf, a) np &lt;- logistic(na[x] - phi) p &lt;- p - np if (log == TRUE) p &lt;- log(p) p } The dordlogit() function works like this: (pk &lt;- dordlogit(1:7, 0, fixef(b11.1)[, 1])) ## [1] 0.12824305 0.09150433 0.10800668 0.23387727 0.14738234 0.14550720 ## [7] 0.14547915 Note the slight difference in how we used dordlogit() with a brm() fit summarized by fixef() than the way McElreath did with a map2stan() fit summarized by coef(). McElreath just put coef(m11.1) into dordlogit(). We, however, more specifically placed fixef(b11.1)[, 1] into the function. With the [, 1] part, we specified that we were working with the posterior means (i.e., Estimate) and neglecting the other summaries (i.e., the posterior SDs and 95% intervals). If you forget to subset, chaos ensues. Next, as McElreath further noted in the text, “these probabilities imply an average outcome of:” sum(pk * (1:7)) ## [1] 4.19909 I found that a bit abstract. Here’s the thing in a more elaborate tibble format. ( explicit_example &lt;- tibble(probability_of_a_response = pk) %&gt;% mutate(the_response = 1:7) %&gt;% mutate(their_product = probability_of_a_response * the_response) ) ## # A tibble: 7 x 3 ## probability_of_a_response the_response their_product ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 0.128 1 0.128 ## 2 0.0915 2 0.183 ## 3 0.108 3 0.324 ## 4 0.234 4 0.936 ## 5 0.147 5 0.737 ## 6 0.146 6 0.873 ## 7 0.145 7 1.02 explicit_example %&gt;% summarise(average_outcome_value = sum(their_product)) ## # A tibble: 1 x 1 ## average_outcome_value ## &lt;dbl&gt; ## 1 4.20 Side note This made me wonder how this would compare if we were lazy and ignored the categorical nature of the response. Here we refit the model with the typical Gaussian likelihood. brm(data = d, family = gaussian, response ~ 1, # in this case, 4 (i.e., the middle response) seems to be the conservative place to put the mean prior = c(prior(normal(4, 10), class = Intercept), prior(cauchy(0, 1), class = sigma)), iter = 2000, warmup = 1000, cores = 4, chains = 4, seed = 11) %&gt;% print() ## Family: gaussian ## Links: mu = identity; sigma = identity ## Formula: response ~ 1 ## Data: d (Number of observations: 9930) ## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1; ## total post-warmup samples = 4000 ## ## Population-Level Effects: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## Intercept 4.20 0.02 4.16 4.24 2600 1.00 ## ## Family Specific Parameters: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## sigma 1.91 0.01 1.88 1.93 3102 1.00 ## ## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample ## is a crude measure of effective sample size, and Rhat is the potential ## scale reduction factor on split chains (at convergence, Rhat = 1). Happily, this yielded a mean estimate of 4.2, much like our average_outcome_value, above. End side note Now we’ll try it by subtracting .5 from each. # The probabilities of a given response (pk &lt;- dordlogit(1:7, 0, fixef(b11.1)[, 1] - .5)) ## [1] 0.08191684 0.06398163 0.08232659 0.20905342 0.15914829 0.18440296 ## [7] 0.21917028 # The average rating sum(pk * (1:7)) ## [1] 4.729425 So the rule is we subtract the linear model from each interecept. Let’s fit our multivariable models. # start values for b11.2 inits &lt;- list(`Intercept[1]` = -1.9, `Intercept[2]` = -1.2, `Intercept[3]` = -0.7, `Intercept[4]` = 0.2, `Intercept[5]` = 0.9, `Intercept[6]` = 1.8, action = 0, intention = 0, contact = 0) b11.2 &lt;- brm(data = d, family = cumulative, response ~ 1 + action + intention + contact, prior = c(prior(normal(0, 10), class = Intercept), prior(normal(0, 10), class = b)), iter = 2000, warmup = 1000, cores = 2, chains = 2, inits = list(inits, inits), seed = 11) # start values for b11.3 inits &lt;- list(`Intercept[1]` = -1.9, `Intercept[2]` = -1.2, `Intercept[3]` = -0.7, `Intercept[4]` = 0.2, `Intercept[5]` = 0.9, `Intercept[6]` = 1.8, action = 0, intention = 0, contact = 0, `action:intention` = 0, `contact:intention` = 0) b11.3 &lt;- update(b11.2, formula = response ~ 1 + action + intention + contact + action:intention + contact:intention, inits = list(inits, inits)) We don’t have a coeftab() function in brms like for rethinking. But as we did for Chapter 6, we can reproduce it with help from the broom package and a bit of data wrangling. library(broom) tibble(model = str_c(&quot;b11.&quot;, 1:3)) %&gt;% mutate(fit = purrr::map(model, get)) %&gt;% mutate(tidy = purrr::map(fit, tidy)) %&gt;% unnest(tidy) %&gt;% select(model, term, estimate) %&gt;% filter(term != &quot;lp__&quot;) %&gt;% complete(term = distinct(., term), model) %&gt;% mutate(estimate = round(estimate, digits = 2)) %&gt;% spread(key = model, value = estimate) %&gt;% # this last step isn&#39;t necessary, but it orders the rows to match the text slice(c(6:11, 1, 4, 3, 2, 5)) ## # A tibble: 11 x 4 ## term b11.1 b11.2 b11.3 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 b_Intercept[1] -1.92 -2.84 -2.63 ## 2 b_Intercept[2] -1.27 -2.16 -1.94 ## 3 b_Intercept[3] -0.72 -1.57 -1.34 ## 4 b_Intercept[4] 0.25 -0.55 -0.31 ## 5 b_Intercept[5] 0.89 0.12 0.37 ## 6 b_Intercept[6] 1.77 1.02 1.27 ## 7 b_action NA -0.71 -0.47 ## 8 b_intention NA -0.72 -0.28 ## 9 b_contact NA -0.96 -0.33 ## 10 b_action:intention NA NA -0.45 ## 11 b_intention:contact NA NA -1.28 If you really wanted that last nobs row at the bottom, you could elaborate on this code: b11.1$data %&gt;% count(). Also, if you want a proper coeftab() function for brms, McElreath’s code lives here. Give it a whirl. Here we compute the WAIC. Caution: This took some time to compute. b11.1 &lt;- add_criterion(b11.1, &quot;waic&quot;) b11.2 &lt;- add_criterion(b11.2, &quot;waic&quot;) b11.3 &lt;- add_criterion(b11.3, &quot;waic&quot;) Now compare the models. loo_compare(b11.1, b11.2, b11.3, criterion = &quot;waic&quot;) %&gt;% print(simplify = F) ## elpd_diff se_diff elpd_waic se_elpd_waic p_waic se_p_waic ## b11.3 0.0 0.0 -18464.5 40.6 11.0 0.1 ## b11.2 -80.4 12.9 -18544.9 38.1 9.0 0.0 ## b11.1 -462.7 31.3 -18927.2 28.8 6.0 0.0 ## waic se_waic ## b11.3 36929.1 81.2 ## b11.2 37089.9 76.3 ## b11.1 37854.4 57.6 Here are the WAIC weights. model_weights(b11.1, b11.2, b11.3, weights = &quot;waic&quot;) %&gt;% round(digits = 3) ## b11.1 b11.2 b11.3 ## 0 0 1 McElreath made Figure 11.3 by extracting the samples of his m11.3, saving them as post, and working some hairy base R plot() code. We’ll take a different route and use brms::fitted(). This will take substantial data wrangling, but hopefully it’ll be instructive. Let’s first take a look at the initial fitted() output for the beginnings of Figure 11.3.a. nd &lt;- tibble(action = 0, contact = 0, intention = 0:1) max_iter &lt;- 100 fitted(b11.3, newdata = nd, subset = 1:max_iter, summary = F) %&gt;% as_tibble() %&gt;% glimpse() ## Observations: 100 ## Variables: 14 ## $ `1.1` &lt;dbl&gt; 0.05999293, 0.06338934, 0.07513009, 0.07297606, 0.06645509… ## $ `2.1` &lt;dbl&gt; 0.08636314, 0.08577635, 0.08875214, 0.08540940, 0.08716579… ## $ `1.2` &lt;dbl&gt; 0.05309269, 0.05894066, 0.06553216, 0.06032632, 0.06085511… ## $ `2.2` &lt;dbl&gt; 0.07248617, 0.07615762, 0.07530632, 0.06889365, 0.07649570… ## $ `1.3` &lt;dbl&gt; 0.07392945, 0.07998119, 0.08755050, 0.08526649, 0.08099358… ## $ `2.3` &lt;dbl&gt; 0.09527508, 0.09820019, 0.09767736, 0.09483805, 0.09720691… ## $ `1.4` &lt;dbl&gt; 0.2140177, 0.2209029, 0.2255002, 0.2138533, 0.2125334, 0.2… ## $ `2.4` &lt;dbl&gt; 0.2437817, 0.2441275, 0.2372103, 0.2255934, 0.2327276, 0.2… ## $ `1.5` &lt;dbl&gt; 0.1727576, 0.1677019, 0.1670171, 0.1701025, 0.1662521, 0.1… ## $ `2.5` &lt;dbl&gt; 0.1680877, 0.1626819, 0.1634772, 0.1679014, 0.1624371, 0.1… ## $ `1.6` &lt;dbl&gt; 0.1917812, 0.1927033, 0.1795038, 0.1929873, 0.1953454, 0.1… ## $ `2.6` &lt;dbl&gt; 0.1626804, 0.1669565, 0.1652491, 0.1792686, 0.1722676, 0.1… ## $ `1.7` &lt;dbl&gt; 0.2344285, 0.2163807, 0.1997662, 0.2044880, 0.2175653, 0.2… ## $ `2.7` &lt;dbl&gt; 0.1713257, 0.1660999, 0.1723275, 0.1780955, 0.1716992, 0.1… Hopefully by now it’s clear why we needed the nd tibble, which we made use of in the newdata = nd argument. Because we set summary = F, we get draws from the posterior instead of summaries. With max_iter, we controlled how many of those posterior draws we wanted. McElreath used 100, which he indicated at the top of page 341, so we followed suit. It took me a minute to wrap my head around the meaning of the 14 vectors, which were named by brms::fitted() default. Notice how each column is named by two numerals, separated by a period. That first numeral indicates which if the two intention values the draw is based on (i.e., 1 stands for intention == 0, 2, stands for intention == 1). The numbers on the right of the decimals are the seven response options for response. For each posterior draw, you get one of those for each value of intention. Finally, it might not be immediately apparent, but the values are in the probability scale, just like pk on page 338. Now we know what we have in hand, it’s just a matter of careful wrangling to get those probabilities into a more useful format to feed into ggplot2. I’ve extensively annotated the code, below. If you lose track of happens in a given step, just run the code up till that point. Go step by step. nd &lt;- tibble(action = 0, contact = 0, intention = 0:1) max_iter &lt;- 100 fitted(b11.3, newdata = nd, subset = 1:max_iter, summary = F) %&gt;% as_tibble() %&gt;% # we convert the data to the long format gather() %&gt;% # we need an variable to index which posterior iteration we&#39;re working with mutate(iter = rep(1:max_iter, times = 14)) %&gt;% # this step isn’t technically necessary, but I prefer my `iter` index at the far left. select(iter, everything()) %&gt;% # here we extract the `intention` and `response` information out of the `key` vector and spread it into two vectors. separate(key, into = c(&quot;intention&quot;, &quot;rating&quot;)) %&gt;% # that step produced two character vectors. they’ll be more useful as numbers mutate(intention = intention %&gt;% as.double(), rating = rating %&gt;% as.double()) %&gt;% # here we convert `intention` into its proper 0:1 metric mutate(intention = intention -1) %&gt;% # this isn&#39;t necessary, but it helps me understand exactly what metric the values are currently in rename(pk = value) %&gt;% # this step is based on McElreath&#39;s R code 11.10 on page 338 mutate(`pk:rating` = pk * rating) %&gt;% # I’m not sure how to succinctly explain this. you’re just going to have to trust me group_by(iter, intention) %&gt;% # this is very important for the next step. arrange(iter, intention, rating) %&gt;% # here we take our `pk` values and make culmulative sums. why? take a long hard look at Figure 11.2. mutate(probability = cumsum(pk)) %&gt;% # `rating == 7` is unnecessary. these `probability` values are by definition 1 filter(rating &lt; 7) %&gt;% ggplot(aes(x = intention, y = probability, color = probability)) + geom_line(aes(group = interaction(iter, rating)), alpha = 1/10) + # note how we made a new data object for `geom_text()` geom_text(data = tibble(text = 1:7, intention = seq(from = .9, to = .1, length.out = 7), probability = c(.05, .12, .20, .35, .53, .71, .87)), aes(label = text), size = 3) + scale_x_continuous(breaks = 0:1) + scale_y_continuous(breaks = c(0, .5, 1)) + coord_cartesian(ylim = 0:1) + scale_color_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + labs(subtitle = &quot;action = 0,\\ncontact = 0&quot;, x = &quot;intention&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) Boom! Okay, that pile of code is a bit of a mess and you’re not going to want to repeatedly cut and paste all that. Let’s condense it into a homemade function, make_Figure_11.3_data(). make_Figure_11.3_data &lt;- function(action, contact, max_iter){ nd &lt;- tibble(action = action, contact = contact, intention = 0:1) max_iter &lt;- max_iter fitted(b11.3, newdata = nd, subset = 1:max_iter, summary = F) %&gt;% as_tibble() %&gt;% gather() %&gt;% mutate(iter = rep(1:max_iter, times = 14)) %&gt;% select(iter, everything()) %&gt;% separate(key, into = c(&quot;intention&quot;, &quot;rating&quot;)) %&gt;% mutate(intention = intention %&gt;% as.double(), rating = rating %&gt;% as.double()) %&gt;% mutate(intention = intention -1) %&gt;% rename(pk = value) %&gt;% mutate(`pk:rating` = pk * rating) %&gt;% group_by(iter, intention) %&gt;% arrange(iter, intention, rating) %&gt;% mutate(probability = cumsum(pk)) %&gt;% filter(rating &lt; 7) } Now we’ll use our sweet homemade function to make our plots. # Figure 11.3.a p1 &lt;- make_Figure_11.3_data(action = 0, contact = 0, max_iter = 100) %&gt;% ggplot(aes(x = intention, y = probability, color = probability)) + geom_line(aes(group = interaction(iter, rating)), alpha = 1/10) + geom_text(data = tibble(text = 1:7, intention = seq(from = .9, to = .1, length.out = 7), probability = c(.05, .12, .20, .35, .53, .71, .87)), aes(label = text), size = 3) + scale_x_continuous(breaks = 0:1) + scale_y_continuous(breaks = c(0, .5, 1)) + scale_color_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + coord_cartesian(ylim = 0:1) + labs(subtitle = &quot;action = 0,\\ncontact = 0&quot;, x = &quot;intention&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) # Figure 11.3.b p2 &lt;- make_Figure_11.3_data(action = 1, contact = 0, max_iter = 100) %&gt;% ggplot(aes(x = intention, y = probability, color = probability)) + geom_line(aes(group = interaction(iter, rating)), alpha = 1/10) + geom_text(data = tibble(text = 1:7, intention = seq(from = .9, to = .1, length.out = 7), probability = c(.12, .24, .35, .50, .68, .80, .92)), aes(label = text), size = 3) + scale_x_continuous(breaks = 0:1) + scale_y_continuous(breaks = c(0, .5, 1)) + scale_color_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + coord_cartesian(ylim = 0:1) + labs(subtitle = &quot;action = 1,\\ncontact = 0&quot;, x = &quot;intention&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) # Figure 11.3.c p3 &lt;- make_Figure_11.3_data(action = 0, contact = 1, max_iter = 100) %&gt;% ggplot(aes(x = intention, y = probability, color = probability)) + geom_line(aes(group = interaction(iter, rating)), alpha = 1/10) + geom_text(data = tibble(text = 1:7, intention = seq(from = .9, to = .1, length.out = 7), probability = c(.15, .34, .44, .56, .695, .8, .92)), aes(label = text), size = 3) + scale_x_continuous(breaks = 0:1) + scale_y_continuous(breaks = c(0, .5, 1)) + scale_color_gradient(low = canva_pal(&quot;Green fields&quot;)(4)[4], high = canva_pal(&quot;Green fields&quot;)(4)[1]) + coord_cartesian(ylim = 0:1) + labs(subtitle = &quot;action = 0,\\ncontact = 1&quot;, x = &quot;intention&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) # here we stitch them together with `grid.arrange()` library(gridExtra) grid.arrange(p1, p2, p3, ncol = 3) If you’d like to learn more about these kinds of models and how to fit them in brms, check out Bürkner and Vuorre’s Ordinal Regression Models in Psychology: A Tutorial. 11.1.4 Bonus: Figure 11.3 alternative. I have a lot of respect for McElreath. But man, Figure 11.3 is the worst. I’m in clinical psychology and there’s no way a working therapist is going to look at a figure like that and have any sense of what’s going on. Nobody’s got time for that. We’ve have clients to serve! Happily, we can go further. Look back at McElreath’s R code 11.10 on page 338. See how he multiplied the elements of pk by their respective response values and then just summed them up to get an average outcome value? With just a little amendment to our custom make_Figure_11.3_data() function, we can wrangle our fitted() output to express average response values for each of our conditions of interest. Here’s the adjusted function: make_data_for_an_alternative_fiture &lt;- function(action, contact, max_iter){ nd &lt;- tibble(action = action, contact = contact, intention = 0:1) max_iter &lt;- max_iter fitted(b11.3, newdata = nd, subset = 1:max_iter, summary = F) %&gt;% as_tibble() %&gt;% gather() %&gt;% mutate(iter = rep(1:max_iter, times = 14)) %&gt;% select(iter, everything()) %&gt;% separate(key, into = c(&quot;intention&quot;, &quot;rating&quot;)) %&gt;% mutate(intention = intention %&gt;% as.double(), rating = rating %&gt;% as.double()) %&gt;% mutate(intention = intention -1) %&gt;% rename(pk = value) %&gt;% mutate(`pk:rating` = pk * rating) %&gt;% group_by(iter, intention) %&gt;% # everything above this point is identical to the previous custom function. # all we do is replace the last few lines with this one line of code. summarise(mean_rating = sum(`pk:rating`)) } Our handy homemade but monstrously-named make_data_for_an_alternative_fiture() function works very much like its predecessor. You’ll see. # alternative to Figure 11.3.a p1 &lt;- make_data_for_an_alternative_fiture(action = 0, contact = 0, max_iter = 100) %&gt;% ggplot(aes(x = intention, y = mean_rating, group = iter)) + geom_line(alpha = 1/10, color = canva_pal(&quot;Green fields&quot;)(4)[1]) + scale_x_continuous(&quot;intention&quot;, breaks = 0:1) + scale_y_continuous(&quot;response&quot;, breaks = 1:7) + coord_cartesian(ylim = 1:7) + labs(subtitle = &quot;action = 0,\\ncontact = 0&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) # alternative to Figure 11.3.b p2 &lt;- make_data_for_an_alternative_fiture(action = 1, contact = 0, max_iter = 100) %&gt;% ggplot(aes(x = intention, y = mean_rating, group = iter)) + geom_line(alpha = 1/10, color = canva_pal(&quot;Green fields&quot;)(4)[1]) + scale_x_continuous(&quot;intention&quot;, breaks = 0:1) + scale_y_continuous(&quot;response&quot;, breaks = 1:7) + coord_cartesian(ylim = 1:7) + labs(subtitle = &quot;action = 1,\\ncontact = 0&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) # alternative to Figure 11.3.c p3 &lt;- make_data_for_an_alternative_fiture(action = 0, contact = 1, max_iter = 100) %&gt;% ggplot(aes(x = intention, y = mean_rating, group = iter)) + geom_line(alpha = 1/10, color = canva_pal(&quot;Green fields&quot;)(4)[1]) + scale_x_continuous(&quot;intention&quot;, breaks = 0:1) + scale_y_continuous(&quot;response&quot;, breaks = 1:7) + coord_cartesian(ylim = 1:7) + labs(subtitle = &quot;action = 0,\\ncontact = 1&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) grid.arrange(p1, p2, p3, ncol = 3) Finally; now those are plots I can sell in a clinical psychology journal! 11.2 Zero-inflated outcomes Very often, the things we can measure are not emissions from any pure process. Instead, they are mixtures of multiple processes. Whenever there are different causes for the same observation, then a mixture model may be useful. A mixture model uses more than one simple probability distribution to model a mixture of causes. In effect, these models use more than one likelihood for the same outcome variable. Count variables are especially prone to needing a mixture treatment. The reason is that a count of zero can often arise more than one way. A “zero” means that nothing happened, and nothing can happen either because the rate of events is low or rather because the process that generates events failed to get started. (p. 342, emphasis in the original) In his Rethinking: Breaking the law box, McElreath discussed how advances in computing have made it possible for working scientists to define their own data generating models. If you’d like to dive deeper into the topic, check out Bürkner’s vignette, Define Custom Response Distributions with brms. We’ll even make use of it a little further down. 11.2.1 Example: Zero-inflated Poisson. Here we simulate our drunk monk data. # define parameters prob_drink &lt;- 0.2 # 20% of days rate_work &lt;- 1 # average 1 manuscript per day # sample one year of production n &lt;- 365 # simulate days monks drink set.seed(11) drink &lt;- rbinom(n, 1, prob_drink) # simulate manuscripts completed y &lt;- (1 - drink) * rpois(n, rate_work) We’ll put those data in a tidy tibble before plotting. d &lt;- tibble(Y = y) %&gt;% arrange(Y) %&gt;% mutate(zeros = c(rep(&quot;zeros_drink&quot;, times = sum(drink)), rep(&quot;zeros_work&quot;, times = sum(y == 0 &amp; drink == 0)), rep(&quot;nope&quot;, times = n - sum(y == 0)) )) ggplot(data = d, aes(x = Y)) + geom_histogram(aes(fill = zeros), binwidth = 1, size = 1/10, color = &quot;grey92&quot;) + scale_fill_manual(values = c(canva_pal(&quot;Green fields&quot;)(4)[1], canva_pal(&quot;Green fields&quot;)(4)[2], canva_pal(&quot;Green fields&quot;)(4)[1])) + xlab(&quot;Manuscripts completed&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) With these data, the likelihood of observing zero on y, (i.e., the likelihood zero manuscripts were completed on a given occasion) is \\[ \\begin{eqnarray} \\text{Pr} (0 | p, \\lambda) &amp; = &amp; \\text{Pr} (\\text{drink} | p) + \\text{Pr} (\\text{work} | p) \\times \\text{Pr} (0 | \\lambda) \\\\ &amp; = &amp; p + (1 - p) \\text{ exp} (- \\lambda) \\end{eqnarray} \\] And since the Poisson likelihood of \\(y\\) is \\(\\text{Pr} (y | \\lambda) = \\lambda^y \\text{exp} (- \\lambda) / y!\\), the likelihood of \\(y = 0\\) is just \\(\\text{exp} (- \\lambda)\\). The above is just the mathematics for: The probability of observing a zero is the probability that the monks didn’t drink OR (\\(+\\)) the probability that the monks worked AND (\\(\\times\\)) failed to finish anything. And the likelihood of a non-zero value \\(y\\) is: \\[ \\begin{eqnarray} \\text{Pr} (y | p, \\lambda) &amp; = &amp; \\text{Pr} (\\text{drink} | p) (0) + \\text{Pr} (\\text{work} | p) \\text{Pr} (y | \\lambda) \\\\ &amp; = &amp; (1 - p) \\frac {\\lambda^y \\text{ exp} (- \\lambda)}{y!} \\end{eqnarray} \\] Since drinking monks never produce \\(y &gt; 0\\), the expression above is just the chance the monks both work \\(1 - p\\), and finish \\(y\\) manuscripts. (p. 344, emphasis in the original) So letting \\(p\\) be the probability \\(y\\) is zero and \\(\\lambda\\) be the shape of the distribution, the zero-inflated Poisson (ZIPoisson) regression model takes the basic form \\[ \\begin{eqnarray} y_i &amp; \\sim &amp; \\text{ZIPoisson} (p_i, \\lambda_i)\\\\ \\text{logit} (p_i) &amp; = &amp; \\alpha_p + \\beta_p x_i \\\\ \\text{log} (\\lambda_i) &amp; = &amp; \\alpha_\\lambda + \\beta_\\lambda x_i \\end{eqnarray} \\] One last thing to note is that in brms, \\(p_i\\) is denoted zi. So the intercept [and zi] only zero-inflated Poisson model in brms looks like this. b11.4 &lt;- brm(data = d, family = zero_inflated_poisson, Y ~ 1, prior = c(prior(normal(0, 10), class = Intercept), prior(beta(2, 2), class = zi)), # the brms default is beta(1, 1) cores = 4, seed = 11) print(b11.4) ## Family: zero_inflated_poisson ## Links: mu = log; zi = identity ## Formula: Y ~ 1 ## Data: d (Number of observations: 365) ## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1; ## total post-warmup samples = 4000 ## ## Population-Level Effects: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## Intercept 0.10 0.08 -0.08 0.26 1179 1.00 ## ## Family Specific Parameters: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## zi 0.24 0.05 0.13 0.33 1354 1.00 ## ## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample ## is a crude measure of effective sample size, and Rhat is the potential ## scale reduction factor on split chains (at convergence, Rhat = 1). The zero-inflated Poisson is parameterized in brms a little differently than it is in rethinking. The different parameterization did not influence the estimate for the Intercept, \\(\\lambda\\). In both here and in the text, \\(\\lambda\\) was about zero. However, it did influence the summary of zi. Note how McElreath’s logistic(-1.39) yielded 0.1994078. Seems rather close to our zi estimate of 0.235. First off, because he didn’t set his seed in the text before simulating, we couldn’t exactly reproduce his simulated drunk monk data. So our results will vary a little due to that alone. But after accounting for simulation variance, hopefully it’s clear that zi in brms is already in the probability metric. There’s no need to convert it. In the prior argument, we used beta(2, 2) for zi and also mentioned in the margin that the brms default is beta(1, 1). To give you a sense of the priors, let’s plot them. tibble(`zi prior`= seq(from = 0, to = 1, length.out = 50)) %&gt;% mutate(`beta(1, 1)` = dbeta(`zi prior`, 1, 1), `beta(2, 2)` = dbeta(`zi prior`, 2, 2)) %&gt;% gather(prior, density, -`zi prior`) %&gt;% ggplot(aes(x = `zi prior`, ymin = 0, ymax = density)) + geom_ribbon(aes(fill = prior)) + scale_fill_manual(values = c(canva_pal(&quot;Green fields&quot;)(4)[4], canva_pal(&quot;Green fields&quot;)(4)[2])) + scale_x_continuous(&quot;prior for zi&quot;, breaks = c(0, .5, 1)) + scale_y_continuous(NULL, breaks = NULL) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), legend.position = &quot;none&quot;) + facet_wrap(~prior) Hopefully this clarifies that the brms default is flat, whereas our prior regularized a bit toward .5. Anyway, here’s that exponentiated \\(\\lambda\\). fixef(b11.4)[1, ] %&gt;% exp() ## Estimate Est.Error Q2.5 Q97.5 ## 1.0998806 1.0881350 0.9271772 1.2984891 11.2.1.1 Overthinking: Zero-inflated Poisson distribution function. dzip &lt;- function(x, p, lambda, log = TRUE) { ll &lt;- ifelse( x == 0, p + (1 - p) * exp(-lambda), (1 - p) * dpois(x, lambda, log = FALSE) ) if (log == TRUE) ll &lt;- log(ll) return(ll) } We can use McElreath’s dzip() to do a posterior predictive check for our model. To work with our estimates for \\(p\\) and \\(\\lambda\\) directly, we’ll set log = F. p_b11.4 &lt;- posterior_summary(b11.4)[2, 1] lambda_b11.4 &lt;- posterior_summary(b11.4)[1, 1] %&gt;% exp() tibble(x = 0:4) %&gt;% mutate(density = dzip(x = x, p = p_b11.4, lambda = lambda_b11.4, log = F)) %&gt;% ggplot(aes(x = x, y = density)) + geom_col(fill = canva_pal(&quot;Green fields&quot;)(4)[4]) + xlab(&quot;Manuscripts completed&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;)) If you look up to the histogram we made at the beginning of this section, you’ll see this isn’t a terrible approximation. 11.3 Over-dispersed outcomes All statistical models omit something. The question is only whether that something is necessary for making useful inferences. One symptom that something important has been omitted from a count model is over-dispersion. The variance of a variable is sometimes called its dispersion. For a counting process like a binomial, the variance is a function of the same parameters as the expected value. For example, the expected value of a binomial is \\(np\\) and its variance is \\(np (1 - p)\\). When the observed variance exceeds this amount—after conditioning on all the predictor variables—this implies that some omitted variable is producing additional dispersion in the observed counts. What could go wrong, if we ignore the over-dispersion? Ignoring it can lead to all of the same problems as ignoring any predictor variable. Heterogeneity in counts can be a confound, hiding effects of interest or producing spurious inferences. (p, 346, emphasis in the original) In this chapter we’ll cope with the problem using continuous mixture models—first the beta-binomial and then the gamma-Poisson (a.k.a. negative binomial). 11.3.1 Beta-binomial. A beta-binomial model assumes that each binomial count observation has its own probability of success. The model estimates the distribution of probabilities of success across cases, instead of a single probability of success. And predictor variables change the shape of this distribution, instead of directly determining the probability of each success. (p, 347, emphasis in the original) Unfortunately, we need to digress. As it turns out, there are multiple ways to parameterize the beta distribution and we’ve run square into two. In the text, McElreath wrote the beta distribution has two parameters, an average probability \\(\\overline{p}\\) and a shape parameter \\(\\theta\\). In his R code 11.24, which we’ll reproduce in a bit, he demonstrated that parameterization with the rethinking::dbeta2() function. The nice thing about this parameterization is how intuitive the pbar parameter is. If you want a beta with an average of .2, you set pbar &lt;- .2. If you want the distribution to be more or less certain, make the theta argument more or less large, respectively. However, the beta density is typically defined in terms of \\(\\alpha\\) and \\(\\beta\\). If you denote the data as \\(y\\), this follows the form \\[\\text{Beta} (y | \\alpha, \\beta) = \\frac{y^{\\alpha - 1} (1 - y)^{\\beta - 1}}{\\text B (\\alpha, \\beta)}\\] which you can verify in the Continuous Distributions on [0, 1] section of the Stan reference manual. In the formula, \\(\\text B\\) stands for the Beta function, which computes a normalizing constant, which you can learn about in the Mathematical Functions of the Stan reference manual. This is all important to be aware of because when we defined that beta prior for zi in the last model, it was using this parameterization. Also, if you look at the base R dbeta() function, you’ll learn it takes two parameters, shape1 and shape2. Those uncreatively-named parameters are the same \\(\\alpha\\) and \\(\\beta\\) from the density, above. They do not correspond to the pbar and theta parameters of McEreath’s rethinking::dbeta2(). McElreath had good reason for using dbeta2(). Beta’s typical \\(\\alpha\\) and \\(\\beta\\) parameters aren’t the most intuitive to use; the parameters in McElreath’s dbeta2() are much nicer. But if you’re willing to dive deeper, it turns out you can find the mean of a beta distribution in terms of \\(\\alpha\\) and \\(\\beta\\) like this \\[\\mu = \\frac{\\alpha}{\\alpha + \\beta}\\] We can talk about the spread of the distribution, sometimes called \\(\\kappa\\), in terms \\(\\alpha\\) and \\(\\beta\\) like this \\[\\kappa = \\alpha + \\beta\\] With \\(\\mu\\) and \\(\\kappa\\) in hand, we can even find the \\(SD\\) of a beta distribution with \\[\\sigma = \\sqrt{\\mu (1 - \\mu) / (\\kappa + 1)}\\] I explicate all this because McElreath’s pbar is \\(\\mu = \\frac{\\alpha}{\\alpha + \\beta}\\) and his theta is \\(\\kappa = \\alpha + \\beta\\). This is great news because it means that we can understand what McElreath did with his beta2() function in terms of base R’s dbeta() function. Which also means that we can understand the distribution of the beta parameters used in brms::brm(). To demonstrate, let’s walk through McElreath’s R code 11.25. pbar &lt;- 0.5 theta &lt;- 5 ggplot(data = tibble(x = seq(from = 0, to = 1, by = .01))) + geom_ribbon(aes(x = x, ymin = 0, ymax = rethinking::dbeta2(x, pbar, theta)), fill = canva_pal(&quot;Green fields&quot;)(4)[1]) + scale_x_continuous(&quot;probability space&quot;, breaks = c(0, .5, 1)) + scale_y_continuous(NULL, breaks = NULL) + ggtitle(expression(paste(&quot;The &quot;, beta, &quot; distribution&quot;)), subtitle = expression(paste(&quot;Defined in terms of &quot;, mu, &quot; (i.e., pbar) and &quot;, kappa, &quot; (i.e., theta)&quot;))) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;)) In his 2014 text, Doing Bayesian Data Analysis, Kruschke provided code for a convenience function that will take pbar and theta as inputs and return the corresponding \\(\\alpha\\) and \\(\\beta\\) values. Here’s the function: betaABfromMeanKappa &lt;- function(mean, kappa) { if (mean &lt;= 0 | mean &gt;= 1) stop(&quot;must have 0 &lt; mean &lt; 1&quot;) if (kappa &lt;= 0) stop(&quot;kappa must be &gt; 0&quot;) a &lt;- mean * kappa b &lt;- (1.0 - mean) * kappa return(list(a = a, b = b)) } Now we can use Kruschke’s betaABfromMeanKappa() to find the \\(\\alpha\\) and \\(\\beta\\) values corresponding to pbar and theta. betaABfromMeanKappa(mean = pbar, kappa = theta) ## $a ## [1] 2.5 ## ## $b ## [1] 2.5 And finally, we can double check that all of this works. Here’s the same distribution but defined in terms of \\(\\alpha\\) and \\(\\beta\\). ggplot(data = tibble(x = seq(from = 0, to = 1, by = .01))) + geom_ribbon(aes(x = x, ymin = 0, ymax = dbeta(x, 2.5, 2.5)), fill = canva_pal(&quot;Green fields&quot;)(4)[4]) + scale_x_continuous(&quot;probability space&quot;, breaks = c(0, .5, 1)) + scale_y_continuous(NULL, breaks = NULL) + ggtitle(expression(paste(&quot;The &quot;, beta, &quot; distribution&quot;)), subtitle = expression(paste(&quot;This time defined in terms of &quot;, alpha, &quot; and &quot;, beta))) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;)) McElreath encouraged us to “explore different values for pbar and theta” (p. 348). Here’s a grid of plots with pbar = c(.25, .5, .75) and theta = c(5, 10, 15) # data tibble(pbar = c(.25, .5, .75)) %&gt;% expand(pbar, theta = c(5, 15, 30)) %&gt;% expand(nesting(pbar, theta), x = seq(from = 0, to = 1, length.out = 100)) %&gt;% mutate(density = rethinking::dbeta2(x, pbar, theta), mu = str_c(&quot;mu == &quot;, pbar %&gt;% str_remove(., &quot;0&quot;)), kappa = str_c(&quot;kappa == &quot;, theta)) %&gt;% mutate(kappa = factor(kappa, levels = c(&quot;kappa == 30&quot;, &quot;kappa == 15&quot;, &quot;kappa == 5&quot;))) %&gt;% # plot ggplot() + geom_ribbon(aes(x = x, ymin = 0, ymax = density), fill = canva_pal(&quot;Green fields&quot;)(4)[4]) + scale_x_continuous(&quot;probability space&quot;, breaks = c(0, .5, 1)) + scale_y_continuous(NULL, labels = NULL) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), axis.ticks.y = element_blank()) + facet_grid(kappa ~ mu, labeller = label_parsed) If you’d like to see how to make a similar plot in terms of \\(\\alpha\\) and \\(\\beta\\), see the chapter 6 document of my project recoding Kruschke’s text into tidyverse and brms code. But remember, we’re not fitting a beta model. We’re using the beta-binomial. “We’re going to bind our linear model to \\(\\overline p\\), so that changes in predictor variables change the central tendency of the distribution” (p. 348). The statistical model we’ll be fitting follows the form \\[ \\begin{eqnarray} \\text{admit}_i &amp; \\sim &amp; \\text{BetaBinomial} (n_i, \\overline p_i, \\theta)\\\\ \\text{logit} (\\overline p_i) &amp; = &amp; \\alpha \\\\ \\alpha &amp; \\sim &amp; \\text{Normal} (0, 2) \\\\ \\theta &amp; \\sim &amp; \\text{Exponential} (1) \\end{eqnarray} \\] Here the size \\(n = \\text{applications}\\). In case you’re confused, yes, our statistical model is not the one McElreath presented at the top of page 348 in the text. If you look closely, the statistical formula he presented does not match up with the one implied by his R code 11.26. Our statistical formula and the brm() model we’ll be fitting, below, correspond to his R code 11.26. Before we fit, we have an additional complication. The beta-binomial distribution is not implemented in brms at this time. However, brms versions 2.2.0 and above allow users to define custom distributions. You can find the handy vignette here. Happily, Bürkner even used the beta-binomial distribution as the exemplar in the vignette. Before we get carried away, let’s load the data. library(rethinking) data(UCBadmit) d &lt;- UCBadmit Unload rethinking and load brms. rm(UCBadmit) detach(package:rethinking, unload = T) library(brms) I’m not going to go into great detail explaining the ins and outs of making custom distributions for brm(). You’ve got Bürkner’s vignette for that. For our purposes, we need two preparatory steps. First, we need to use the custom_family() function to define the name and parameters of the beta-binomial distribution for use in brm(). Second, we have to define some functions for Stan which are not defined in Stan itself. We’ll save them as stan_funs. Third, we’ll make a stanvar() statement which will allow us to pass our stan_funs to brm(). beta_binomial2 &lt;- custom_family( &quot;beta_binomial2&quot;, dpars = c(&quot;mu&quot;, &quot;phi&quot;), links = c(&quot;logit&quot;, &quot;log&quot;), lb = c(NA, 0), type = &quot;int&quot;, vars = &quot;trials[n]&quot; ) stan_funs &lt;- &quot; real beta_binomial2_lpmf(int y, real mu, real phi, int T) { return beta_binomial_lpmf(y | T, mu * phi, (1 - mu) * phi); } int beta_binomial2_rng(real mu, real phi, int T) { return beta_binomial_rng(T, mu * phi, (1 - mu) * phi); } &quot; stanvars &lt;- stanvar(scode = stan_funs, block = &quot;functions&quot;) With that out of the way, we’re almost ready to test this baby out. Before we do, a point of clarification: What McElreath referred to as the shape parameter, \\(\\theta\\), Bürkner called the precision parameter, \\(\\phi\\). In our exposition, above, we followed Kruschke’s convention and called it \\(\\kappa\\). These are all the same thing: \\(\\theta\\), \\(\\phi\\), and \\(\\kappa\\) are all the same thing. Perhaps less confusingly, what McElreath called the pbar parameter, \\(\\bar{p}\\), Bürkner simply called \\(\\mu\\). b11.5 &lt;- brm(data = d, family = beta_binomial2, # here&#39;s our custom likelihood admit | trials(applications) ~ 1, prior = c(prior(normal(0, 2), class = Intercept), prior(exponential(1), class = phi)), iter = 4000, warmup = 1000, cores = 2, chains = 2, stanvars = stanvars, # note our `stanvars` seed = 11) Success, our results look a lot like those in the text! print(b11.5) ## Family: beta_binomial2 ## Links: mu = logit; phi = identity ## Formula: admit | trials(applications) ~ 1 ## Data: d (Number of observations: 12) ## Samples: 2 chains, each with iter = 4000; warmup = 1000; thin = 1; ## total post-warmup samples = 6000 ## ## Population-Level Effects: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## Intercept -0.38 0.31 -0.99 0.24 4058 1.00 ## ## Family Specific Parameters: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## phi 2.77 0.95 1.29 4.97 3663 1.00 ## ## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample ## is a crude measure of effective sample size, and Rhat is the potential ## scale reduction factor on split chains (at convergence, Rhat = 1). Here’s what the corresponding posterior_samples() data object looks like. post &lt;- posterior_samples(b11.5) head(post) ## b_Intercept phi lp__ ## 1 -0.48894704 3.660582 -70.37537 ## 2 0.04534325 4.072111 -72.44047 ## 3 -0.57268470 2.827876 -70.24965 ## 4 -0.07413730 1.750735 -71.15664 ## 5 -0.52303155 3.324634 -70.24396 ## 6 -0.27625574 2.279246 -70.24819 Here’s our median and percentile-based 95% interval. post %&gt;% tidybayes::median_qi(inv_logit_scaled(b_Intercept)) %&gt;% mutate_if(is.double, round, digits = 3) ## inv_logit_scaled(b_Intercept) .lower .upper .width .point .interval ## 1 0.406 0.271 0.559 0.95 median qi To stay within the tidyverse while making the many thin lines in Figure 11.5.a, we’re going to need to do a bit of data processing. First, we’ll want a variable to index the rows in post (i.e., to index the posterior draws). And we’ll want to convert the b_Intercept to the \\(\\bar{p}\\) metric with the inv_logit_scaled() function. Then we’ll use sample_n() to randomly draw a subset of the posterior draws. Then with the expand() function, we’ll insert a tightly-spaced sequence of x values ranging between 0 and 1–the parameter space of beta distribution. Finally, we’ll use pmap_dbl() to compute the density values for the rethinking::dbeta2 distribution corresponding to the unique combination of x, p_bar, and phi values in each row. set.seed(11) lines &lt;- post %&gt;% mutate(iter = 1:n(), p_bar = inv_logit_scaled(b_Intercept)) %&gt;% sample_n(size = 100) %&gt;% expand(nesting(iter, p_bar, phi), x = seq(from = 0, to = 1, by = .005)) %&gt;% mutate(density = pmap_dbl(list(x, p_bar, phi), rethinking::dbeta2)) str(lines) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 20100 obs. of 5 variables: ## $ iter : int 4 4 4 4 4 4 4 4 4 4 ... ## $ p_bar : num 0.481 0.481 0.481 0.481 0.481 ... ## $ phi : num 1.75 1.75 1.75 1.75 1.75 ... ## $ x : num 0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 ... ## $ density: num Inf 1.78 1.59 1.5 1.43 ... All that was just for the thin lines. To make the thicker line for the posterior mean, we’ll get tricky with stat_function(). lines %&gt;% ggplot(aes(x = x, y = density)) + stat_function(fun = rethinking::dbeta2, args = list(prob = mean(inv_logit_scaled(post[, 1])), theta = mean(post[, 2])), color = canva_pal(&quot;Green fields&quot;)(4)[4], size = 1.5) + geom_line(aes(group = iter), alpha = .2, color = canva_pal(&quot;Green fields&quot;)(4)[4]) + scale_y_continuous(NULL, breaks = NULL) + coord_cartesian(ylim = 0:3) + xlab(&quot;probability admit&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;)) There are other ways to do this. For ideas, check out my blog post Make rotated Gaussians, Kruschke style. Before we can do our variant of Figure 11.5.b, we’ll need to define a few more custom functions. The log_lik_beta_binomial2() and predict_beta_binomial2() functions are required for brms::predict() to work with our family = beta_binomial2 brmfit object. Similarly, fitted_beta_binomial2() is required for brms::fitted() to work properly. And before all that, we need to throw in a line with the expose_functions() function. Just go with it. expose_functions(b11.5, vectorize = TRUE) # Required to use `predict()` log_lik_beta_binomial2 &lt;- function(i, draws) { mu &lt;- draws$dpars$mu[, i] phi &lt;- draws$dpars$phi N &lt;- draws$data$trials[i] y &lt;- draws$data$Y[i] beta_binomial2_lpmf(y, mu, phi, N) } predict_beta_binomial2 &lt;- function(i, draws, ...) { mu &lt;- draws$dpars$mu[, i] phi &lt;- draws$dpars$phi N &lt;- draws$data$trials[i] beta_binomial2_rng(mu, phi, N) } # Required to use `fitted()` fitted_beta_binomial2 &lt;- function(draws) { mu &lt;- draws$dpars$mu trials &lt;- draws$data$trials trials &lt;- matrix(trials, nrow = nrow(mu), ncol = ncol(mu), byrow = TRUE) mu * trials } With those intermediary steps out of the way, we’re ready to make Figure 11.5.b. # The prediction intervals predict(b11.5) %&gt;% as_tibble() %&gt;% transmute(ll = Q2.5, ul = Q97.5) %&gt;% # The fitted intervals bind_cols( fitted(b11.5) %&gt;% as_tibble() ) %&gt;% # The original data used to fit the model bind_cols(b11.5$data) %&gt;% mutate(case = 1:12) %&gt;% # plot ggplot(aes(x = case)) + geom_linerange(aes(ymin = ll / applications, ymax = ul / applications), color = canva_pal(&quot;Green fields&quot;)(4)[1], size = 2.5, alpha = 1/4) + geom_pointrange(aes(ymin = Q2.5 / applications, ymax = Q97.5 / applications, y = Estimate/applications), color = canva_pal(&quot;Green fields&quot;)(4)[4], size = 1/2, shape = 1) + geom_point(aes(y = admit/applications), color = canva_pal(&quot;Green fields&quot;)(4)[2], size = 2) + scale_x_continuous(breaks = 1:12) + scale_y_continuous(breaks = c(0, .5, 1)) + coord_cartesian(ylim = 0:1) + labs(subtitle = &quot;Posterior validation check&quot;, y = &quot;Admittance probability&quot;) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;), axis.ticks.x = element_blank(), legend.position = &quot;none&quot;) As in the text, the raw data are consistent with the prediction intervals. But those intervals are so incredibly wide, they’re hardly an endorsement of the model. Once we learn about hierarchical models, we’ll be able to do much better. 11.3.2 Negative-binomial or gamma-Poisson. Recall the Poisson distribution presumes \\(\\sigma^2\\) scales with \\(\\mu\\). The negative binomial distribution relaxes this assumption and presumes “each Poisson count observation has its own rate. It estimates the shape of a gamma distribution to describe the Poisson rates across cases” (p. 350). Here’s a look at the \\(\\gamma\\) distribution. mu &lt;- 3 theta &lt;- 1 ggplot(data = tibble(x = seq(from = 0, to = 12, by = .01)), aes(x = x)) + geom_ribbon(aes(ymin = 0, ymax = rethinking::dgamma2(x, mu, theta)), color = &quot;transparent&quot;, fill = canva_pal(&quot;Green fields&quot;)(4)[4]) + geom_vline(xintercept = mu, linetype = 3, color = canva_pal(&quot;Green fields&quot;)(4)[3]) + scale_x_continuous(NULL, breaks = c(0, mu, 10)) + scale_y_continuous(NULL, breaks = NULL) + coord_cartesian(xlim = 0:10) + ggtitle(expression(paste(&quot;Our sweet &quot;, gamma, &quot;(3, 1)&quot;))) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;)) 11.3.2.1 Bonus: Let’s fit a negative-binomial model. McElreath didn’t give an example of negative-binomial regression in the text. Here’s one with the UCBadmit data. brm(data = d, family = negbinomial, admit ~ 1 + applicant.gender, prior = c(prior(normal(0, 10), class = Intercept), prior(normal(0, 1), class = b), prior(gamma(0.01, 0.01), class = shape)), # this is the brms default iter = 4000, warmup = 1000, cores = 2, chains = 2, seed = 11) %&gt;% print() ## Family: negbinomial ## Links: mu = log; shape = identity ## Formula: admit ~ 1 + applicant.gender ## Data: d (Number of observations: 12) ## Samples: 2 chains, each with iter = 4000; warmup = 1000; thin = 1; ## total post-warmup samples = 6000 ## ## Population-Level Effects: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## Intercept 4.70 0.40 3.99 5.58 4439 1.00 ## applicant.gendermale 0.57 0.50 -0.43 1.52 4929 1.00 ## ## Family Specific Parameters: ## Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat ## shape 1.23 0.48 0.50 2.36 4408 1.00 ## ## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample ## is a crude measure of effective sample size, and Rhat is the potential ## scale reduction factor on split chains (at convergence, Rhat = 1). Since the negative-binomial model uses the log link, you need to exponentiate to get the estimates back into the count metric. E.g., exp(4.7) ## [1] 109.9472 Also, you may have noticed we used the brms default prior(gamma(0.01, 0.01), class = shape) for the shape parameter. Here’s what that prior looks like. ggplot(data = tibble(x = seq(from = 0, to = 60, by = .1)), aes(x = x)) + geom_ribbon(aes(ymin = 0, ymax = dgamma(x, 0.01, 0.01)), color = &quot;transparent&quot;, fill = canva_pal(&quot;Green fields&quot;)(4)[2]) + scale_x_continuous(NULL) + scale_y_continuous(NULL, breaks = NULL) + coord_cartesian(xlim = 0:50) + ggtitle(expression(paste(&quot;Our brms default &quot;, gamma, &quot;(0.01, 0.01) prior&quot;))) + theme_hc() + theme(plot.background = element_rect(fill = &quot;grey92&quot;)) 11.3.3 Over-dispersion, entropy, and information criteria. Both the beta-binomial and the gamma-Poisson models are maximum entropy for the same constraints as the regular binomial and Poisson. They just try to account for unobserved heterogeneity in probabilities and rates. So while they can be a lot harder to fit to data, they can be usefully conceptualized much like ordinary binomial and Poisson GLMs. So in terms of model comparison using information criteria, a beta-binomial model is a binomial model, and a gamma-Poisson (negative-binomial) is a Poisson model. (pp. 350–351) Reference McElreath, R. (2016). Statistical rethinking: A Bayesian course with examples in R and Stan. Chapman &amp; Hall/CRC Press. Session info sessionInfo() ## R version 3.5.1 (2018-07-02) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS High Sierra 10.13.6 ## ## Matrix products: default ## BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] parallel stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] rethinking_1.80 viridis_0.5.1 viridisLite_0.3.0 ## [4] ggbeeswarm_0.6.0 dutchmasters_0.1.0 ghibli_0.2.0 ## [7] hrbrthemes_0.6.0 broom_0.5.1 rcartocolor_1.0.0 ## [10] gridExtra_2.3 loo_2.1.0 wesanderson_0.3.6.9000 ## [13] GGally_1.4.0 tidybayes_1.0.4 bayesplot_1.6.0 ## [16] fiftystater_1.0.1 bindrcpp_0.2.2 ggrepel_0.8.0 ## [19] ggthemes_4.0.1 forcats_0.3.0 stringr_1.3.1 ## [22] dplyr_0.8.0.1 purrr_0.2.5 readr_1.1.1 ## [25] tidyr_0.8.1 tibble_2.1.1 tidyverse_1.2.1 ## [28] brms_2.8.0 Rcpp_1.0.0 rstan_2.18.2 ## [31] StanHeaders_2.18.0-1 ggplot2_3.1.0 ## ## loaded via a namespace (and not attached): ## [1] pacman_0.4.6 utf8_1.1.4 ## [3] ggstance_0.3 tidyselect_0.2.5 ## [5] htmlwidgets_1.2 grid_3.5.1 ## [7] munsell_0.5.0 codetools_0.2-15 ## [9] DT_0.4 future_1.8.1 ## [11] miniUI_0.1.1.1 withr_2.1.2 ## [13] Brobdingnag_1.2-5 colorspace_1.3-2 ## [15] knitr_1.20 rstudioapi_0.7 ## [17] stats4_3.5.1 Rttf2pt1_1.3.7 ## [19] listenv_0.7.0 labeling_0.3 ## [21] mnormt_1.5-5 bridgesampling_0.4-0 ## [23] rprojroot_1.3-2 coda_0.19-2 ## [25] generics_0.0.2 xfun_0.3 ## [27] R6_2.3.0 markdown_0.8 ## [29] HDInterval_0.2.0 reshape_0.8.7 ## [31] assertthat_0.2.0 promises_1.0.1 ## [33] scales_1.0.0 beeswarm_0.2.3 ## [35] gtable_0.2.0 globals_0.12.1 ## [37] processx_3.2.1 rlang_0.3.1 ## [39] extrafontdb_1.0 lazyeval_0.2.1 ## [41] inline_0.3.15 yaml_2.1.19 ## [43] reshape2_1.4.3 abind_1.4-5 ## [45] modelr_0.1.2 threejs_0.3.1 ## [47] crosstalk_1.0.0 backports_1.1.2 ## [49] httpuv_1.4.4.2 rsconnect_0.8.8 ## [51] extrafont_0.17 tools_3.5.1 ## [53] psych_1.8.4 bookdown_0.9 ## [55] RColorBrewer_1.1-2 ggridges_0.5.0 ## [57] plyr_1.8.4 base64enc_0.1-3 ## [59] ps_1.2.1 prettyunits_1.0.2 ## [61] zoo_1.8-2 haven_1.1.2 ## [63] magrittr_1.5 blogdown_0.8 ## [65] colourpicker_1.0 mvtnorm_1.0-8 ## [67] matrixStats_0.54.0 hms_0.4.2 ## [69] shinyjs_1.0 mime_0.5 ## [71] evaluate_0.10.1 arrayhelpers_1.0-20160527 ## [73] xtable_1.8-2 shinystan_2.5.0 ## [75] readxl_1.1.0 rstantools_1.5.0 ## [77] compiler_3.5.1 crayon_1.3.4 ## [79] htmltools_0.3.6 later_0.7.3 ## [81] lubridate_1.7.4 MASS_7.3-50 ## [83] Matrix_1.2-14 cli_1.0.1 ## [85] bindr_0.1.1 igraph_1.2.1 ## [87] pkgconfig_2.0.2 foreign_0.8-70 ## [89] xml2_1.2.0 svUnit_0.7-12 ## [91] dygraphs_1.1.1.5 vipor_0.4.5 ## [93] rvest_0.3.2 callr_3.1.0 ## [95] digest_0.6.18 rmarkdown_1.10 ## [97] cellranger_1.1.0 gdtools_0.1.7 ## [99] shiny_1.1.0 gtools_3.8.1 ## [101] nlme_3.1-137 jsonlite_1.5 ## [103] fansi_0.4.0 pillar_1.3.1 ## [105] lattice_0.20-35 httr_1.3.1 ## [107] pkgbuild_1.0.2 glue_1.3.0 ## [109] xts_0.10-2 shinythemes_1.1.1 ## [111] stringi_1.2.3 "]
]
